import '../types/webxr.js';
import { Event as ThreeEvent, EventDispatcher, PerspectiveCamera, Vector3, WebGLRenderer } from 'three';
import { ModelScene } from './ModelScene.js';
import { Renderer } from './Renderer.js';
export declare type ARStatus = 'not-presenting' | 'session-started' | 'object-placed' | 'failed';
export declare const ARStatus: {
    [index: string]: ARStatus;
};
export interface ARStatusEvent extends ThreeEvent {
    status: ARStatus;
}
declare const $presentedScene: unique symbol;
declare const $placementBox: unique symbol;
declare const $lastTick: unique symbol;
declare const $turntableRotation: unique symbol;
declare const $oldShadowIntensity: unique symbol;
declare const $oldBackground: unique symbol;
declare const $rafId: unique symbol;
export declare const $currentSession: unique symbol;
declare const $tick: unique symbol;
declare const $refSpace: unique symbol;
declare const $viewerRefSpace: unique symbol;
declare const $frame: unique symbol;
declare const $initialized: unique symbol;
declare const $initialModelToWorld: unique symbol;
declare const $placementComplete: unique symbol;
declare const $initialHitSource: unique symbol;
declare const $transientHitTestSource: unique symbol;
declare const $inputSource: unique symbol;
declare const $isTranslating: unique symbol;
declare const $isRotating: unique symbol;
declare const $isScaling: unique symbol;
declare const $lastDragPosition: unique symbol;
declare const $lastScalar: unique symbol;
declare const $goalPosition: unique symbol;
declare const $goalYaw: unique symbol;
declare const $goalScale: unique symbol;
declare const $xDamper: unique symbol;
declare const $yDamper: unique symbol;
declare const $zDamper: unique symbol;
declare const $yawDamper: unique symbol;
declare const $scaleDamper: unique symbol;
declare const $damperRate: unique symbol;
declare const $resolveCleanup: unique symbol;
declare const $exitWebXRButtonContainer: unique symbol;
export declare const $onWebXRFrame: unique symbol;
declare const $postSessionCleanup: unique symbol;
declare const $updateCamera: unique symbol;
declare const $placeInitially: unique symbol;
declare const $getHitPoint: unique symbol;
declare const $onSelectStart: unique symbol;
declare const $onSelectEnd: unique symbol;
declare const $onUpdateScene: unique symbol;
declare const $fingerSeparation: unique symbol;
declare const $processInput: unique symbol;
declare const $moveScene: unique symbol;
declare const $onExitWebXRButtonContainerClick: unique symbol;
export declare class ARRenderer extends EventDispatcher {
    private renderer;
    threeRenderer: WebGLRenderer;
    camera: PerspectiveCamera;
    private [$placementBox];
    private [$lastTick];
    private [$turntableRotation];
    private [$oldShadowIntensity];
    private [$oldBackground];
    private [$rafId];
    protected [$currentSession]: XRSession | null;
    private [$refSpace];
    private [$viewerRefSpace];
    private [$frame];
    private [$initialHitSource];
    private [$transientHitTestSource];
    private [$inputSource];
    private [$presentedScene];
    private [$resolveCleanup];
    private [$exitWebXRButtonContainer];
    private [$initialized];
    private [$initialModelToWorld];
    private [$placementComplete];
    private [$isTranslating];
    private [$isRotating];
    private [$isScaling];
    private [$lastDragPosition];
    private [$lastScalar];
    private [$goalPosition];
    private [$goalYaw];
    private [$goalScale];
    private [$xDamper];
    private [$yDamper];
    private [$zDamper];
    private [$yawDamper];
    private [$scaleDamper];
    private [$damperRate];
    private [$onExitWebXRButtonContainerClick];
    constructor(renderer: Renderer);
    resolveARSession(scene: ModelScene): Promise<XRSession>;
    /**
     * The currently presented scene, if any
     */
    get presentedScene(): ModelScene | null;
    /**
     * Resolves to true if the renderer has detected all the necessary qualities
     * to support presentation in AR.
     */
    supportsPresentation(): Promise<boolean>;
    /**
     * Present a scene in AR
     */
    present(scene: ModelScene): Promise<void>;
    /**
     * If currently presenting a scene in AR, stops presentation and exits AR.
     */
    stopPresenting(): Promise<void>;
    [$postSessionCleanup](): void;
    /**
     * True if a scene is currently in the process of being presented in AR
     */
    get isPresenting(): boolean;
    [$onUpdateScene]: () => void;
    updateTarget(): void;
    [$updateCamera](view: XRView): void;
    [$placeInitially](frame: XRFrame): void;
    [$getHitPoint](hitResult: XRHitTestResult): Vector3 | null;
    /**
     * This sets the initial model placement based on the input hit point. The
     * bottom of the model will be placed on the floor (the shadow will rest on
     * the input's y-coordinate). The XZ placement is found by first putting the
     * scene's target at the hit point, drawing a ray from the camera to the
     * target, and finding the XZ-intersection of this ray with the model's
     * bounding box. The scene is then translated on the XZ plane to position this
     * intersection point at the input hit point. If the ray does not intersect,
     * the target is left at the hit point.
     *
     * This ensures the model is placed according to the chosen target, is not
     * reoriented, and does not intersect the camera even when the model
     * is large (unless the target is chosen outside of the model's bounding box).
     */
    placeModel(hit: Vector3): void;
    [$onSelectStart]: (event: Event) => void;
    [$onSelectEnd]: () => void;
    [$fingerSeparation](fingers: XRTransientInputHitTestResult[]): number;
    [$processInput](frame: XRFrame): void;
    [$moveScene](delta: number): void;
    [$tick](): void;
    [$onWebXRFrame](time: number, frame: XRFrame): void;
}
export {};
