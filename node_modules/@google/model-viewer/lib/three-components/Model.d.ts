import { AnimationClip, Box3, Object3D, Vector3 } from 'three';
import ModelViewerElementBase from '../model-viewer-base.js';
import { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';
import { Hotspot } from './Hotspot.js';
import { Shadow } from './Shadow.js';
export declare const DEFAULT_FOV_DEG = 45;
export declare const SAFE_RADIUS_RATIO: number;
export declare const DEFAULT_TAN_FOV: number;
export declare const $shadow: unique symbol;
declare const $cancelPendingSourceChange: unique symbol;
declare const $currentGLTF: unique symbol;
/**
 * An Object3D that can swap out its underlying model.
 */
export default class Model extends Object3D {
    protected [$shadow]: Shadow | null;
    private [$currentGLTF];
    private mixer;
    private [$cancelPendingSourceChange];
    private animationsByName;
    private currentAnimationAction;
    animations: Array<AnimationClip>;
    modelContainer: Object3D;
    animationNames: Array<string>;
    boundingBox: Box3;
    size: Vector3;
    idealCameraDistance: number;
    fieldOfViewAspect: number;
    userData: {
        url: string | null;
    };
    url: string | null;
    get currentGLTF(): ModelViewerGLTFInstance | null;
    /**
     * Creates a model.
     */
    constructor();
    /**
     * Returns a boolean indicating whether or not there is a
     * loaded model attached.
     */
    hasModel(): boolean;
    /**
     * Pass in a THREE.Object3D to be controlled
     * by this model.
     */
    setObject(model: Object3D): void;
    setSource(element: ModelViewerElementBase, url: string | null, progressCallback?: (progress: number) => void): Promise<void>;
    set animationTime(value: number);
    get animationTime(): number;
    get hasActiveAnimation(): boolean;
    /**
     * Plays an animation if there are any associated with the current model.
     * Accepts an optional string name of an animation to play. If no name is
     * provided, or if no animation is found by the given name, always falls back
     * to playing the first animation.
     */
    playAnimation(name?: string | null, crossfadeTime?: number): void;
    stopAnimation(): void;
    updateAnimation(step: number): void;
    clear(): void;
    /**
     * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D
     * object to be framed tightly in a 2D window of any aspect ratio without
     * clipping at any camera orbit. The camera's center target point can be
     * optionally specified. If no center is specified, it defaults to the center
     * of the bounding box, which means asymmetric models will tend to be tight on
     * one side instead of both. Proper choice of center can correct this.
     */
    updateFraming(center?: Vector3 | null): void;
    /**
     * Sets the shadow's intensity, lazily creating the shadow as necessary.
     */
    setShadowIntensity(shadowIntensity: number, shadowSoftness: number): void;
    /**
     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the
     * shadow's resolution. This involves reallocation, so it should not be
     * changed frequently. Softer shadows are cheaper to render.
     */
    setShadowSoftness(softness: number): void;
    /**
     * The shadow must be rotated manually to match any global rotation applied to
     * this model. The input is the global orientation about the Y axis.
     */
    setShadowRotation(radiansY: number): void;
    /**
     * Call when updating the shadow; returns true if an update is needed and
     * resets the state.
     */
    updateShadow(): boolean;
    /**
     * Shift the floor vertically from the bottom of the model's bounding box by
     * offset (should generally be negative).
     */
    setShadowScaleAndOffset(scale: number, offset: number): void;
    /**
     * The following methods are for operating on the set of Hotspot objects
     * attached to the scene. These come from DOM elements, provided to slots by
     * the Annotation Mixin.
     */
    addHotspot(hotspot: Hotspot): void;
    removeHotspot(hotspot: Hotspot): void;
    /**
     * Helper method to apply a function to all hotspots.
     */
    forHotspots(func: (hotspot: Hotspot) => void): void;
    /**
     * Update the CSS visibility of the hotspots based on whether their normals
     * point toward the camera.
     */
    updateHotspots(viewerPosition: Vector3): void;
    /**
     * Rotate all hotspots to an absolute orientation given by the input number of
     * radians. Zero returns them to upright.
     */
    orientHotspots(radians: number): void;
    /**
     * Set the rendering visibility of all hotspots. This is used to hide them
     * during transitions and such.
     */
    setHotspotsVisibility(visible: boolean): void;
}
export {};
