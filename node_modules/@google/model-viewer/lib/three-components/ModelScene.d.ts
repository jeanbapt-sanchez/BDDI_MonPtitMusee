import { Camera, Event as ThreeEvent, Object3D, PerspectiveCamera, Scene, Vector2, Vector3 } from 'three';
import ModelViewerElementBase from '../model-viewer-base.js';
import Model from './Model.js';
export interface ModelLoadEvent extends ThreeEvent {
    url: string;
}
export interface ModelSceneConfig {
    element: ModelViewerElementBase;
    canvas: HTMLCanvasElement;
    width: number;
    height: number;
}
export declare type IlluminationRole = 'primary' | 'secondary';
export declare const IlluminationRole: {
    [index: string]: IlluminationRole;
};
/**
 * A THREE.Scene object that takes a Model and CanvasHTMLElement and
 * constructs a framed scene based off of the canvas dimensions.
 * Provides lights and cameras to be used in a renderer.
 */
export declare class ModelScene extends Scene {
    aspect: number;
    canvas: HTMLCanvasElement;
    shadowIntensity: number;
    shadowSoftness: number;
    width: number;
    height: number;
    isDirty: boolean;
    element: ModelViewerElementBase;
    context: CanvasRenderingContext2D | ImageBitmapRenderingContext | null;
    exposure: number;
    model: Model;
    canScale: boolean;
    framedFieldOfView: number;
    activeCamera: Camera;
    camera: PerspectiveCamera;
    private goalTarget;
    private targetDamperX;
    private targetDamperY;
    private targetDamperZ;
    constructor({ canvas, element, width, height }: ModelSceneConfig);
    /**
     * Function to create the context lazily, as when there is only one
     * <model-viewer> element, the renderer's 3D context can be displayed
     * directly. This extra context is necessary to copy the renderings into when
     * there are more than one.
     */
    createContext(): void;
    /**
     * Sets the model via URL.
     */
    setModelSource(source: string | null, progressCallback?: (progress: number) => void): Promise<void>;
    /**
     * Updates the ModelScene for a new container size in CSS pixels.
     */
    setSize(width: number, height: number): void;
    /**
     * Set's the framedFieldOfView based on the aspect ratio of the window in
     * order to keep the model fully visible at any camera orientation.
     */
    frameModel(): void;
    /**
     * Returns the size of the corresponding canvas element.
     */
    getSize(): {
        width: number;
        height: number;
    };
    /**
     * Returns the current camera.
     */
    getCamera(): Camera;
    /**
     * Sets the passed in camera to be used for rendering.
     */
    setCamera(camera: Camera): void;
    /**
     * Called when the model's contents have loaded, or changed.
     */
    onModelLoad(event: {
        url: string;
    }): void;
    /**
     * Sets the point in model coordinates the model should orbit/pivot around.
     */
    setTarget(modelX: number, modelY: number, modelZ: number): void;
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getTarget(): Vector3;
    /**
     * Shifts the model to the target point immediately instead of easing in.
     */
    jumpToGoal(): void;
    /**
     * This should be called every frame with the frame delta to cause the target
     * to transition to its set point.
     */
    updateTarget(delta: number): void;
    /**
     * Yaw the +z (front) of the model toward the indicated world coordinates.
     */
    pointTowards(worldX: number, worldZ: number): void;
    /**
     * Yaw is the scene's orientation about the y-axis, around the rotation
     * center.
     */
    set yaw(radiansY: number);
    get yaw(): number;
    /**
     * Sets the shadow's intensity, lazily creating the shadow as necessary.
     */
    setShadowIntensity(shadowIntensity: number): void;
    /**
     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the
     * shadow's resolution. This involves reallocation, so it should not be
     * changed frequently. Softer shadows are cheaper to render.
     */
    setShadowSoftness(softness: number): void;
    /**
     * This method returns the world position and model-space normal of the point
     * on the mesh corresponding to the input pixel coordinates given relative to
     * the model-viewer element. If the mesh is not hit, the result is null.
     */
    positionAndNormalFromPoint(pixelPosition: Vector2, object?: Object3D): {
        position: Vector3;
        normal: Vector3;
    } | null;
}
