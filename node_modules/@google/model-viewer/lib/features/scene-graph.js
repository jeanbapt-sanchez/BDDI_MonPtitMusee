/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { ModelKernel } from '@google/3dom/lib/api/model-kernel.js';
import { ModelGraftManipulator } from '@google/3dom/lib/facade/model-graft-manipulator.js';
import { ModelGraft } from '@google/3dom/lib/facade/three-js/model-graft.js';
import { ThreeDOMMessageType } from '@google/3dom/lib/protocol';
import { property } from 'lit-element';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter';
import { $needsRender, $onModelLoad, $scene } from '../model-viewer-base.js';
import { $shadow } from '../three-components/Model.js';
const $updateThreeSide = Symbol('updateThreeSide');
const $currentGLTF = Symbol('currentGLTF');
const $modelGraft = Symbol('modelGraft');
const $mainPort = Symbol('mainPort');
const $threePort = Symbol('threePort');
const $manipulator = Symbol('manipulator');
const $modelKernel = Symbol('modelKernel');
const $onModelChange = Symbol('onModelChange');
const $onModelGraftMutation = Symbol('onModelGraftMutation');
/**
 * SceneGraphMixin manages a `<model-viewer>` integration with the 3DOM library
 * in order to support operations on the <model-viewer> scene graph.
 */
export const SceneGraphMixin = (ModelViewerElement) => {
    var _a, _b, _c, _d, _e, _f, _g;
    var _h;
    class SceneGraphModelViewerElement extends ModelViewerElement {
        constructor() {
            super(...arguments);
            this[_h] = null;
            this[_a] = null;
            this[_b] = null;
            this[_c] = null;
            this[_d] = null;
            this[_e] = null;
            this[_f] = (event) => {
                const { data } = event;
                if (data && data.type === ThreeDOMMessageType.MODEL_CHANGE) {
                    const serialized = data.model;
                    const currentKernel = this[$modelKernel];
                    if (currentKernel != null) {
                        currentKernel.deactivate();
                    }
                    else if (serialized == null) {
                        // Do not proceed if transitioning from null to null
                        return;
                    }
                    if (serialized != null) {
                        this[$modelKernel] = new ModelKernel(data.port, serialized);
                    }
                    else {
                        this[$modelKernel] = null;
                    }
                    this.dispatchEvent(new CustomEvent('scene-graph-ready', { detail: { url: serialized ? serialized.modelUri : null } }));
                }
            };
            this[_g] = (_event) => {
                this[$needsRender]();
            };
        }
        // ThreeDOM implementation:
        /** @export */
        get model() {
            const kernel = this[$modelKernel];
            return kernel ? kernel.model : undefined;
        }
        connectedCallback() {
            super.connectedCallback();
            const { port1, port2 } = new MessageChannel();
            port1.start();
            port2.start();
            this[$mainPort] = port1;
            this[$threePort] = port2;
            this[$mainPort].onmessage = this[$onModelChange];
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[$mainPort].close();
            this[$threePort].close();
            this[$mainPort] = null;
            this[$threePort] = null;
            if (this[$manipulator] != null) {
                this[$manipulator].dispose();
            }
            if (this[$modelKernel] != null) {
                this[$modelKernel].deactivate();
            }
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has($modelGraft)) {
                const oldModelGraft = changedProperties.get($modelGraft);
                if (oldModelGraft != null) {
                    oldModelGraft.removeEventListener('mutation', this[$onModelGraftMutation]);
                }
                const modelGraft = this[$modelGraft];
                if (modelGraft != null) {
                    modelGraft.addEventListener('mutation', this[$onModelGraftMutation]);
                }
            }
        }
        [(_h = $modelGraft, _a = $currentGLTF, _b = $mainPort, _c = $threePort, _d = $manipulator, _e = $modelKernel, $onModelLoad)]() {
            super[$onModelLoad]();
            this[$updateThreeSide]();
        }
        [$updateThreeSide]() {
            // Three.js side (will eventually move to worker)
            const scene = this[$scene];
            const { model } = scene;
            const { currentGLTF } = model;
            let modelGraft = null;
            let manipulator = null;
            if (currentGLTF != null) {
                const { correlatedSceneGraph } = currentGLTF;
                const currentModelGraft = this[$modelGraft];
                const currentManipulator = this[$manipulator];
                if (correlatedSceneGraph != null) {
                    if (currentManipulator != null) {
                        currentManipulator.dispose();
                    }
                    if (currentModelGraft != null && currentGLTF === this[$currentGLTF]) {
                        return;
                    }
                    modelGraft = new ModelGraft(model.url || '', correlatedSceneGraph);
                    let channel = null;
                    if (modelGraft != null && modelGraft.model != null) {
                        channel = new MessageChannel();
                        manipulator = new ModelGraftManipulator(modelGraft, channel.port1);
                        this[$threePort].postMessage({
                            type: ThreeDOMMessageType.MODEL_CHANGE,
                            model: modelGraft.model.toJSON(),
                            port: channel.port2
                        }, [channel.port2]);
                    }
                    else {
                        this[$threePort].postMessage({
                            type: ThreeDOMMessageType.MODEL_CHANGE,
                            model: null,
                            port: null
                        });
                    }
                }
            }
            this[$modelGraft] = modelGraft;
            this[$manipulator] = manipulator;
            this[$currentGLTF] = currentGLTF;
        }
        /** @export */
        async exportScene(options) {
            const { model } = this[$scene];
            return new Promise(async (resolve, reject) => {
                if (model == null) {
                    return reject('Model missing or not yet loaded');
                }
                // Defaults
                const opts = {
                    binary: true,
                    onlyVisible: true,
                    maxTextureSize: Infinity,
                    forcePowerOfTwoTextures: false,
                    includeCustomExtensions: false,
                    embedImages: true
                };
                Object.assign(opts, options);
                // Not configurable
                opts.animations = model.animations;
                opts.truncateDrawRange = true;
                const shadow = model[$shadow];
                let visible = false;
                // Remove shadow from export
                if (shadow != null) {
                    visible = shadow.visible;
                    shadow.visible = false;
                }
                const exporter = new GLTFExporter();
                exporter.parse(model.modelContainer, (gltf) => {
                    return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {
                        type: opts.binary ? 'application/octet-stream' :
                            'application/json'
                    }));
                }, opts);
                if (shadow != null) {
                    shadow.visible = visible;
                }
            });
        }
    }
    _f = $onModelChange, _g = $onModelGraftMutation;
    __decorate([
        property({ type: Object })
    ], SceneGraphModelViewerElement.prototype, _h, void 0);
    return SceneGraphModelViewerElement;
};
//# sourceMappingURL=scene-graph.js.map